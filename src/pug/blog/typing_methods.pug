extends _blog.pug

block append subtitle
  | Alphanumeric input

block content
  h2 Alphanumeric input
  hr
  p
    i 27 March 2023 <br>
  hr

  h3 1. Introduction
  p When using device without a physical keyboard (mobile phone, videogame console, smart TV) or when using a keyboard is not possible (disability use cases), it is necessary to find alternative methods for sending alphanumerical input to such devices.
  p #[+ax('https://en.wikipedia.org/wiki/Feature_phone') Feature phones] used keypad typing #[i (Fig. A)].
  p While smartphones, videogame consoles, and computers uses on-screen virtual keyboards #[i (Fig. B)].
  +figure(
    'A',
    'Nokia 3210 keypad (1999)',
    '/static/blog/keypad.jpg',
    'small inline'
  )
  +figure(
    'B',
    'Windows 10 on-screen keyboard (2015)',
    '/static/blog/win_keyboard.jpg',
    'big inline'
  )

  p In the context of a computer dedicated to videogames, or a videogame console, the most frequent use cases for alphanumeric input are:
  ul
    li Search box input in a game launcher, game shop, or internet browser.
    li Sign-up forms and/or sign-in with credentials (user and password).
    li Basic chat communication.

  p At Input Labs, we developed the Alpakka firmware with the goal of not requiring additional software or drivers. Following this goal we also want to explore potential input mechanisms for alphanumeric characters that would work in a videogame controller without additional software not operating system support, analyze the limitations, and evaluate potential solutions.

  hr
  h3 2. Limitations / considerations

  h4 2.1. Not enough buttons
  p The most obvious limitation when not having a physical keyboard is that alternatives do not have so many buttons (100+ buttons) available. In a standard layout controller (e.g. Xbox controller) we will have about 14 buttons and 6 axis.
  p We could also consider motion (gyro) input, but that would drastically limit the potential application of our research. And since we want to develop methods that are not only compatible with standard controllers but also with one-hand controllers (#[+a('/kapybara') Kapybara]), we want to limit ourselves to one thumbstick (2 axis) and only a subset of all available buttons (ideally between 4 and 8 buttons).

  h4 2.2 Visual feedback and discoverability
  p On-screen keyboard comes with some limitations:
  ul
    li May be not available on elevated credential dialogs or screens.
    li May be not available when playing videogames on exclusive fullscreen.
  p We want to explore alternatives to the on-screen keyboard that can overcome these limitations, but it is reasonable to assume that no matter how we do the mapping of buttons and visual feedback, the discoverability will be seriously compromised, as it will be impossible for a person to use the solution for first time without checking a video introduction or reading the reference/manual.
  p Ideally we have to figure out abstractions that facilitate learning and mistake recovery after that initial introduction to the solution.

  //- pre: code.
  //-     ///
  //-      â”‚
  //-      â–¼
  //-   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  //-   â”‚User knows how to type the next character?â”‚
  //-   â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
  //-      â”‚                                 â”‚
  //-      â”‚YES                              â”‚NO
  //-      â”‚                                 â”‚
  //-      â–¼                                 â–¼
  //-   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  //-   â”‚User typed the      â”‚â—„â”€â”€â”€â”€â”€â”¤User utilizes a   â”‚
  //-   â”‚character correctly?â”‚      â”‚discovery resourceâ”‚
  //-   â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚to learn how      â”‚
  //-      â”‚       â”‚     â–²          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  //-      â”‚YES    â”‚NO   â”‚                   :
  //-      â”‚       â”‚     â”‚                   :
  //-      â”‚       â–¼     â”‚                   â–¼
  //-      â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  //-      â”‚   â”‚User deletes  â”‚        â”‚Reinforced â”‚
  //-      â”‚   â”‚last characterâ”‚ - - - â–ºâ”‚learning   â”‚
  //-      â–¼   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  //-     ///

  h4 2.4. Manipulation complexity
  p Since neither of the potential solutions would be as straight forward as "one-button-one-character", the solutions we evaluate have to avoid abstractions that are complex to manipulate:
  ul
    li Avoid using solutions that rely on timing between button presses.
    li Avoid requiring the use multiple of fingers, the less fingers required the better.
    li Avoid requiring very accurate movement in analog controls (thumbstick, gyro).
    li Avoid simultaneous input in which the user is required do perform actions with multiple fingers at once, specially if one or more of the actions involve analog input.

  h4 2.5. Typing speed
  p Even though typing speed should not be a priority goal for the solutions we are looking for, we could argue that solutions that are easy to learn and remember could also result in faster characters-per-minute typing speeds, specially during the learning period.

  hr
  h3 3. Specific solutions

  h4 3.1 Mapping of controls
  p Since a controller has significantly fewer buttons than a keyboard, we have to find alternative ways to map characters to these limited buttons or analog control surfaces.
  ul
    li #[em Grouping] several characters, for example #[em A], #[em B], #[em C] into the a single physical button or selectable, then choosing one of these characters by:
    ul
      li Pressing the button repeatedly during a fixed amount of time to cycle through the characters, as was one common solution on feature phones (aka writing SMS messages in the 2000s) #[i (fig. A)].
      li Using simultaneously a button or control surface to preselect a character group, then using another button or control surface to cycle or select the final character. As for example in the Steam Controller #[em Daisywheel] #[i (fig. C)].
    li Using the analog surfaces to allow input in which each character is clearly distinguishable, as for example #[em character recognition].

  +figure(
    'A',
    'Nokia 3210 keypad (1999)',
    '/static/blog/keypad.jpg',
    'small inline'
  )
  +figure(
    'C',
    'Steam Controller Daisywheel (2015)',
    '/static/blog/daisywheel.png',
    'small inline'
  )

  h4 3.2. Preview and commit characters
  p Since we do not want to rely on OS integration (so no on-screen keyboard), one of the potential solutions we tried is to apply the concept of #[em preview and commit] characters that was used in #[em feature phones], in which a single button or action is used for cycling between several characters, and only later the character is "committed" when certain conditions are met (other button is pressed, or after a defined period of time).
  +figure(
    'D',
    'Character preview and commit',
    '/static/blog/sms.gif',
    'small'
  )
  p This same concept can be used in PC by sending (and deleting) characters on demand. Unfortunately in our tests we found that this solution  it is #[em not compatible with 100%] of the PC use cases, as for example it may be problematic:
  ul
    li If a searchbox is auto-completing what is written on it, and "auto-committing" characters.
    li If searchbox suggestions rendering is making the system to get unresponsive.
    li If the input is obscured as in a password field.
    li If the UI is expecting a simple key press (binding menu).

  hr
  h3 4. General solutions (early evaluation)
  p We evaluated a total of #[em 9 potential typing methods], and we created early implementations for 7.
  //- p All of these were conceived to be integrated as part of the Alpakka #[+a('/alpakka/manual/profile_desktop') Desktop profile].
  p This is a high level view of the characteristics, advantages and disadvantages we found on each of these methods:

  table.manual.hdiv.col4
    tr
      td
      th Controls / character grouping
      th Notes

    tr
      th Daisywheel
      td
        div #[b Primary:] Thumbstick direction.
        div &nbsp;
        div #[b Secondary:] ABXY.
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div ----  ABCD  EFGH
          div IJKL  ----  OMN-
          div PQRS  TUV-  WXYZ
      td
        ul
          li No preview.
          li Inspired by Steam Controller implementation.
          li Keypad-style grouping.
          li Vowels on cardinal directions.
          li Optimized for letter frequency (english).

    tr
      th Analog keypad, 3 variants
      td
        div #[b Primary:] Thumbstick direction.
        div &nbsp;
        div #[b Secondary:] Thumbstick radius (cycle next on outer ring, commit when back to center).
        div &nbsp;
        div #[b Secondary alt:] Mousewheel (cycle next or prev, commit when TS back to center).
        div &nbsp;
        div #[b Secondary alt:] Thumbstick dial cycling (cycle by turning around thumbstick clockwise or anticlockwise, 90Â° each cycle, commit when back to center).
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div ----  ABCD  EFGH
          div IJKL  ----  OMN-
          div PQRS  TUV-  WXYZ
      td
        ul
          li Preview is optional.
          li Keypad-style grouping.
          li Vowels on cardinal directions.
          li Optimized for letter frequency (english).
          li Hard to perform due to accurate or simultaneous input required.
          li Thumbstick dialing later evolved into #[em glyph-stick] method.

    tr
      th Clover keyboard
      td
        div #[b Primary:] ABXY.
        div &nbsp;
        div #[b Secondary:] Thumbstick direction (and push).
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div (X)  (A)  (B)  (Y)
          div QWE  RTY  UIO  P
          div ASD  FGH  JKL  ;
          div ZXC  VBN  M,.  /
      td
        ul
          li No preview.
          li Grouped as querty keyboard sections.
          li Named as tribute to Daisywheel.
          li Very hard to discover and remember mapping.

    tr
      th Qwerty rows
      td
        div #[b Primary:] L4 and R4.
        div &nbsp;
        div #[b Secondary:] Dpad, Select, ABXY.
        div &nbsp;
        div #[b Grouping:]
        div.mono
          div (L4): &nbsp;&nbsp; QWERTYUIO
          div (R4): &nbsp;&nbsp; ASDFGHJKL
          div (L4+R4): ZXCVBNMP
      td
        ul
          li No preview.
          li Grouped as querty keyboard rows.
          li Possibly very hard to discover and remember mapping.
          li It requires using at least 4 fingers.
          li Too many buttons required to use in single-hand devices.

    tr
      th Glyph-stick
      td
        div #[b Primary:] Thumbstick (glyph evaluated when stick is back to center).
        div &nbsp;
        div: i (No grouping, see glyph table below)
      td
        ul
          li No preview.
          li Glyphs resemble actual character glyphs.
          li Glyphs are optimized so more frequent characters use shorter glyphs if possible.
          li All glyphs start and end into a cardinal direction.

    tr
      th Gyro projected keyboard
      td
        div #[b Primary:] L1 (Starts projection from the center, commits when released).
        div &nbsp;
        div #[b Secondary:] Gyro (Moves the virtual cursor within the projection boundaries).
        div &nbsp;
        div: i (No grouping)
      td
        ul
          li Preview is required.
          li Like the Playstation 4 on-screen gyro keyboard, but without the on-screen keyboard.
          li Requires to remember querty keyboard layout quite well.
          li There is no way to know how close to switch character the virtual cursor is.

    tr
      th Gyro character recognition
      td
        div #[b Primary:] L1 (Starts character recognition, try to match character on release).
        div &nbsp;
        div #[b Secondary:] Gyro (Moves the virtual "pen").
        div &nbsp;
        div: i (No grouping)
      td
        ul
          li No preview.
          li As in writing on the air.
          li Firmware implementation would be very hard to develop.
          li Would require to adapt to user's specific way to write characters?.

  hr
  h3 5. General solutions (further evaluation)
  p From all the methods evaluated, we decided to do further testing with 2 of them: #[em Daisywheel] and #[em Glyph-stick], as we found these the most promising solutions, being the easier to understand and learn, not requiring preview-and-commit, and being easier to remember.

  table.manual.hdiv.col3
    tr
      td Method
      th Implementation
      th Evaluation status
    tr
      th Daisywheel
      td Beta (soon)
      td In progress ğŸŸ¢
    tr
      th Analog keypad
      td Alpha
      td Discontinued
    tr
      th Clover keyboard
      td Alpha
      td Discontinued
    tr
      th Qwerty rows
      td None (concept)
      td Discontinued
    tr
      th Glyph-stick
      td Beta (soon)
      td In progress ğŸŸ¢
    tr
      th Gyro projected keyboard
      td Alpha
      td Discontinued
    tr
      th Gyro character recognition
      td None (concept)
      td Delayed indefinitely


  h4 5.1. Daisywheel
  ul
    li Based on Steam Controller / Steam Input daisywheel method.
    li The #[em thumbstick] direction pre-selects a group of 4 characters, final selection is made with #[em ABXY] buttons.
    li Eventually, it should be possible to edit the grouping in the profiles.
    li Classic variant:
    ul
      li Alphabetical grouping, same than the original daisywheel.
      li Order of face buttons is #[em X], #[em Y], #[em B], #[em A].
    li Tweaked variant:
    ul
      li Keypad-style grouping, but adapted for having no center key.
      li Order of face buttons is #[em A], #[em B], #[em X], #[em Y].
      li #[em O] and #[em U] are relocated so all vowels are on the #[em A button].
      li #[em X] and #[em Y] are relocated on the #[em X button] and #[em Y button].
    li Currently under consideration for beta testing, as part of the #[+a('/alpakka/manual/profile_desktop') Desktop profile].

  +figure(
    null,
    'Daisywheel classic (Steam Controller)',
    '/static/blog/daisywheel_classic.png',
    'big inline'
  )
  +figure(
    null,
    'Daisywheel tweaked (Input Labs)',
    '/static/blog/daisywheel_tweaked.png',
    'big inline'
  )

  h4 5.2. Glyph-stick
  ul
    li #[em Thumbstick] is used for basic pattern recognition (glyphs).
    li It is usable with a single finger, or even no fingers.
    li Glyph patterns are designed to resemble the characters they represent, so they are easier to remember.
    li All glyphs start/end from the center into a cardinal direction (left, right, up, down).
    li Glyph is evaluated when returning to center.
    li Shorter patterns are used for more frequent characters (in english).
    li Eventually, it should be possible to edit glyphs in the profiles.
    li Currently under consideration for beta testing, as part of the #[+a('/alpakka/manual/profile_desktop') Desktop profile].
  +figure(
    null,
    '',
    '/static/blog/glyph-stick.png',
    'big'
  )

  hr
  h3 6. Next steps
  p The plan is to gather feedback, and to do beta testing with our testers. Based on the results, some of these mechanisms may become part of future firmware releases. These will then be iterated and improved accordingly.
  p Another blog article may provide further details on those tests, iterations and their results, as well as the according findings and conclusions.


  hr
  p Thanks a lot for the support! <br> - M&M <3



